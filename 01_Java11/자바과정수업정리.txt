회원가입
1. 구글
2. github
3. 오라클
   www.oracle.com


JDK 다운로드
java.oracle.com
(https://www.oracle.com/java/technologies/)


java 개발 환경 3가지 ( 기준: 디바이스:장치)

1) Java SE ( Java Standard Edition)
   - 일반 PC
   - Java 기술
   - JDK 설치함으로 구축 가능

2) Java EE ( Java Enterprise Edition)
   - 웹서버 ( Tomcat 9 )
    예> 웹 페이지 개발
   - 서블릿,JSP
   - Tomcat 설치함으로 구축 가능

3) Java ME ( Java Micro Edition)
   - 휴대용 장치
    

JDK(Java Development Kit) 설치
기본설치폴더(JDK홈디렉터리):
C:\Program Files\Java\jdk-11

환경변수 설정
시작오른쪽클릭> 시스템 > 고급 시스템 설정 > 환경변수 > 시스템 변수
# JAVA_HOME용도: JDK홈디렉터리 지정
JAVA_HOME=C:\Program Files\Java\jdk-11

# path용도: 명령어 경로 지정
javac.exe  java.exe 
PATH=C:\Program Files\Java\jdk-11;값2;값3


자바에서 사용되는 압축 형식 3가지
1) jar
  - *.class 파일들이 압축된 형식
  예> *.jar

2) war
  - 서블릿/jsp로 만든 웹 어플리케이션 압축된 형식
  예> *.war
 
3) ear
  - jar + war ===> ear로 압축
   예> *.ear


eclipse 개발 도구 ( IDE 툴 )
- 인텔리제이
  www.jetbrains.com
- VSC

www.eclipse.org

download > Download Packages
주의할점 2가지
1) JDK 버전 확인
2) SE 환경 개발?
     - 비웹개발
     Eclipse IDE for Java Developers

   EE 환경 개발?
     - 웹개발
     Eclipse IDE for Enterprise Java and Web Developers

eclipse 설치후 설정

window > preference > 
general > workspace 
> text file encoding 값을 utf-8로 설정.
==> utf-8로 설정해야 한글사용이 가능

window > preference > 
general > Appearance > Colors and Fonts 
> Basic  > Text Font
==> 글꼴설정

window > preference > Java
> Installed JREs

==> eclipse에 내장된 openjdk 대신에
   우리가 설치한 jdk11 사용하도록 변경하자.
###########################################
프로젝트 생성
File > New  > Java Project 선택 

Project Name 지정,
JRE는 JavaSE-11 설정,
Module는 체크 해제하기.

#############################
API의 메뉴얼 제공: API문서 ( API documentation)
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/module-summary.html

#######################
소스파일 작성 ( *.java )

1) 클래스 이름지정 방법
   - 반드시 첫글자는 영문자 또는 _ 또는 $ 만 가능
     이후에 숫자지정 가능.

   - 대소문자 구별

   - 클래스는 첫글자는 반드시 대문자로 지정 ( 관례 )

   - 특수문자는 2개만 가능 ( _, $ )

   - 단어간 공백문자 불가


2) public static  void main( String [] args ) 필수
 ==> 반드시 위 코드 형식으로 지정해야 된다.
 ==> main 메서드라고 부른다.
 ==> 실행하기 위한 시작점(starting point ) 역할이다.

# 생성된 소스
public class Hello {

	public static void main(String[] args) {

	}
}

==> 클래스명(Hello)과 파일명(Hello.java)이 일치해야 된다.
==> 대소문자 구별
==> 클래스 갯수는 3개 
     Hello: 개발자가 만든 클래스
     String: API
     System: API


==> Hello.java 소스파일 작성
        |     컴파일, 컴파일러( javac.exe ), eclipse가 자동으로 해줌.
    Hello.class (byte code, package explore에서는 안보임. navigator에서 보임 )
        |     실행, 인터프리터 ( java.exe )
       결과   ( 콘솔(console)에 결과값이 출력됨 )	    



######################################################
이클립스 단축키
1. 한줄 삭제
    ctrl + d

2. 줄 바꿈
    alt + 화살표키

3. 한줄 복사
   ctrl + alt + 화살표키

4. 명령어 취소
   ctrl + z

5. 파일저장
   ctrl + s

6. 콘솔 출력
   sysout하고 ctrl + spacebar

7. 한줄 주석
   //  , ctrl + / ( 토글 )

8. 여러줄 주석
   /*
       , ctrl + shift +  /
   */

######################################################
식별자 ( identifier )
1. 개념:
    자바소스의 단어 의미

2. 문법
   - 첫글자는 반드시 영문자 또는 특수문자( _, $)
     이후에 숫자지정 가능
   - 대소문자 구별함.
   - 한글지정 가능. (권장안함)

3. 대상 3가지

  1) 클래스
     - 첫글자는 반드시 대문자
     - 권장은 명사형 

  2) 변수
     - 소문자
     - 권장은 명사형

  3) 메서드
     - 소문자
     - 권장은 동사형

4. 식별자 종류 2가지 ( 기준은 주체 )

  가. API
     - 이름이 정해져 있음 ( 예약어, 키워드 )
     - 시스템 정의 식별자
     예> String, System, static, void, public, class
         println, interface, abstract, protected, private,
	 final, transient, default, switch, if, for,..........

  나. 개발자(사용자)
     - 사용자 정의 식별자
     예> args, Hello
     - 반드시 예약어는 제외하고 지정해야 된다. (***********)

==> 나머지 연산자(operator)와 값(데이터,리터럴:literal)으로 구성됨.
   리터럴 형식
   :  "홍길동"
      '남'
      35
      true
      183.45


  ##############################
  () : 소괄호
  {} : 중괄호
  [] : 대괄호
  #########################################################
자바의 데이터 종류 ( 데이터형, data type ) ===> 무조건 외우기
==> 자바언어가 인식 가능한 데이터 종류가 무엇인지 살펴보자.

  가. 기본형 데이터형 ( Primitive Data Type: PDT )
  
      - 수치형 --- 정수 :   byte (  1byte )
                         short ( 2byte )
			 int   ( 4byte ) : 기본
			 long  ( 8byte )
                   - 10진수, 2진수, 8진수, 16진수 모두 사용 가능
                    예>  10진수: 100, -30, 0
                        2진수: 0|1 이용 ( 0b값 )
		             0b1, 0b0
                        8진수: 0~7 이용 ( 0값 )
			      01, 02,...07
                        16진수: 0~9, A,B,C,D,E,F 이용 ( 0x값)
			      0x0, 0x1,..... 0xF
			       

             ---- 실수 :  float ( 4byte )
	                 double ( 8byte ) : 기본
                         - 소수점이용, 지수표현 가능
		 예>  3.14 ( 3.14D, 3.14d ) ===> double로 처리됨

			   3.14F ( 3.14f)  ====> float로 처리됨


      - 문자형 -- char ( 2byte, 캐릭터라고 읽음 )
                   -자바는 전세계의 모든 글자 표현 가능 (한글포함)
                   -이스케이프 문자(escape) 지정 가능
		     예> \t ( tab 클릭효과 얻음) 
		        \n  ( enter 효과 얻음 )
			\"  ( " 출력 )
			\'  ( ' 출력 )
			\\  ( \ 출력 )

	           - 단 하나의 문자 표현식에  사용됨.
		     반드시 '' (홑따옴표)로 감싸야 된다.
		     예>  '남',  '여' ,  'A', 'B'
                  
		  * 문자열은 참조형이다.
                   ==> 문자열은 문자가 여러개
		   ==> 반드시 "" (쌍따옴표)로 감싸야 된다.
		   예> "홍길동", "서울"
		   ==> String 클래스 타입으로 관리됨
		   
      - 논리형 : boolean ( 1byte, 불린 라고 읽음 )
                 - 참/거짓 표현
		   참은 true 표현되고
		   거짓은 false(기본) 표현됨.

  ====> 기본형 데이터 갯수는 8개이다.

  나. 참조형 데이터형 ( Reference Data Type: RDT )
     - 기본형 8개 제외한 나머지가 모두 참조형이다.
     - 대표적으로 클래스, 인터페이스, 배열이다. (****************)
############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# 자바 소개 및 특징
https://velog.io/@kojam9041/Java-%EC%9E%90%EB%B0%94-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%ED%8A%B9%EC%A7%95
https://s-bug.tistory.com/57

# 진법 관련 짧은 동영상 
2진수, 8진수, 10진수, 16진수 변환 공부 하실 때 참고
https://www.youtube.com/watch?v=y26oXFInsoI
https://www.youtube.com/shorts/WJo3bZlbHwg
https://www.youtube.com/shorts/dTT_cQrIQJk
https://www.youtube.com/shorts/JonWf0occWw
https://www.youtube.com/shorts/GyOZc9lY_BM
https://www.youtube.com/shorts/lm3Z4ALBHXY
https://www.youtube.com/shorts/FQGLS10uYOk
https://www.youtube.com/shorts/AY5CECThfZ0

# 자바 데이터 타입, 변수, 리터럴 
https://catsbi.oopy.io/6541026f-1e19-4117-8fef-aea145e4fc1b
############################################################################
############################################################################


Hello.java ( 소스파일, 영단어로 구성, 자바인식 불가 )
  |
  |  <=== 자바가 인식가능한 코드로 변경해야 된다.
  |       컴파일 한다고 한다.
  |
Hello.class (byte code, 자바인식이 가능)
##############################################################
1일차 리뷰

1. 자바 3가지 환경
  - Java SE: 기본개발 환경, JDK 설치(2개의 환경변수: JAVA_HOME, PATH )
  - Java EE: 웹 개발 환경 ( 서블릿/jsp ), Tomcat설치
  - Java ME: 모바일 환경

2. 자바 특징
  - 플랫폼(OS)에 독립적==> 생성된 class 파일을 어떤 OS에서도 그냥 실행이 가능하다.
  - 객체지향 프로그래밍(Object Oriented Programming: OOP )

3. 자바 프로그램 개발 순서

   1) 소스작성 ( Hello.java )
      - 개발자가 이해할 수 있는 영단어 코드로 구성
   
   2) 컴파일 단계 ( javac.exe 컴파일러 이용 )
       Hello.java ----------> Hello.class ( bytecode )
      
      문법: javac  Hello.java

   3) 실행 단계 ( java.exe 인터프리터 이용 )
      Hello.class ----------------> 결과값 출력

      문법: java  Hello

4. JVM ( Java Virtual Machine)
  - 역할: bytecode인 class 실행시킴
  - JDK설치하면 JVM이 구축됨
  - S/W이지만 H/W 특징을 가짐 ( 다양한 메모리 포함 )
    주요 메모리: stack, heap, method area

5. 자바에서 사용 가능한 데이터 종류 ( ***************** )

   가. 기본형 데이터 ( 데이터종류, data type )
      - Primitive Data Type: PDT
      - 종류:
               수치형  - 정수형 : byte  (1byte)
	                       short (2byte)
			       int   (4byte): 기본
			       long  (8byte)
			      
			      정수값(리터럴)표현: 10진수, 2진수(0|1), 8진수(0~7), 
			                      16진수(0~9,A,B,C,D,E,F) 모두 사용 가능
                                         예>   10    0b값   0값   0x값
			      만약에 100 정수를 쓰면 기본인 int로 처리가  된다. 	
			      long으로 처리하고 싶으면 100L 지정한다.
					 
	                실수형 : float (4byte) 
                               double (8byte): 기본
                              실수값(리터럴)표현: 소수점이용, 지수표현 가능
			           예>  31.4, 31.4D   ===> double 처리
				       31.4F  ==> float 처리


	       문자형          : char(2byte)
                               -문자형(리터럴)표현: 반드시 '' 사용
			        예> 'A', '남'
                               - escape 문자 ( \t, \n, \\, \', \" )
			       - 전세계의 모든 문자 표현 가능

	       논리형          : boolean (1byte)
                                논리형(리터럴)표현:   true, false


   나. 참조형 데이터 
      - Reference Data Type: RDT
      - 기본형 8개 제외한 나머지 모두
       대표적: 클래스, 인터페이스, 배열
##############################################################################
2일차

1. 정수에서 long 타입으로 사용할 때는 다음과 같이 정수값L 지정한다.
  예> 300L

2. 기본형 8개에 해당되는 클래스 8개를 제공한다.

 기본형          참조형(클래스) ==> wrapper 클래스라고 부른다.
 ----------------------------
 byte		Byte
 short		Short
 int		Integer
 long		Long

 float		Float
 double		Double

 char		Character
 boolean        Boolean


#################################################
3. 변수 ( variable )

  1) 용도
    - 데이터 저장 ( 기본형 데이터 및 참조형 데이터 저장용도 )
    - 언제든지 값이 변경될 수 있음.

  2)사용방법 3단계
    (1) 변수선언
        - 데이터가 저장된 영역 확보 작업 ( 메모리에 저장되고 메모리 위치에 해당되는 이름 지정)
	- 문법:

	    데이터타입 변수명;
         예>  int num;      // int 때문에 4byte 영역확보
	     String name;  // String 참조형이기 때문에 4byte 영역확보

    (2) 변수초기화
        - 생성된 변수에 처음 값을 저장하는 작업
        - 문법:
	     변수명=값;

         예>  num = 19;
	     name = "홍길동";

    (3) 변수 사용
       System.out.println(num);  // 19
       System.out.println(name);


     (4) 변수값 변경
        num=29;
        System.out.println(num);  // 29


4. 기본형 변수 vs 참조형 변수

  1) 기본형 변수
    - 기본형 데이터를 저장하는 변수
    예> 
        int num;   // 실제값이 저장
	num = 20;
    
    ==> num 변수안에 20이 저장됨.

  2) 참조형 변수
    - 참조형 데이터를 저장하는 변수
   
   예>
       String name;  // 주소값이 저장
       name ="홍길동";

   ==> name 변수 안에 "홍길동"이 저장된 주소값이 저장됨.

5. 변수 종류 ( **************************)
  - 변수 선언 위치와 용도에 따른 분류

  가. 로컬 변수 ( local variable )
      - 메서드안에서 선언
      - 생성시점: 메서드 호출시 변수생성됨 
        제거시점: 메서드 호출후 작업이 모두 끝났을 때
      - 생성횟수: 메서드 호출할때마다 매번 생성되고 
                메서드 작업이 끝나면 매번 삭제됨. ( 일시적으로 사용할 목적으로 주로 사용됨 )
      - 저장메모리: stack 메모리
      - 선언만하고 초기화하지 않으면 자동초기화 안됨.
        반드시 사용전에 초기화해야 된다. (******************)
  나. 인스턴스 변수 ( instance variable )
      - 메서드 밖에서 선언
      - 생성시점: 클래스 객체 생성(new 키워드 이용)시 변수생성됨 
        제거시점: 클래스 객체가 제거될 때 변수가 삭제됨.
          ==> 개발자가 클래스를 사용하기 위해서 new 이용한다. ( 클래스 영역 확보 )
	      사용된 클래스 영역을 제거는 개발자가 하지 않고 자바가 자동으로 제거해준다.
	      제거해주는 프로세스는 GC ( Garbage Collector)가 해준다.
	  ==> C 언어는 영역 확보 및 제거를 개발자가 모두 직접 해야된다.
      - 생성횟수: new 할때마다 매번 생성.
      - 저장메모리: heap 메모리
      - 선언만하고 초기화하지 않으면 자동으로 기본값으로 초기화된다.
        기본형:
	    정수: 0
	    실수: 0.0
	    문자: \u0000
	    논리: false
	참조형: null
  다. 클래스 변수 ( class variable, static variable)
      - 메서드 밖에서 선언 + static 키워드 추가
      - 생성시점: 프로그램 실행시 변수 생성됨 
        제거시점: 프로그램 종료시 변수가 삭제됨.
      - 생성횟수: 1 번
      - 저장메모리: method area 메모리  
      - 선언만하고 초기화하지 않으면 자동으로 기본값으로 초기화된다.
        기본형:
	    정수: 0
	    실수: 0.0
	    문자: \u0000
	    논리: false

	참조형: null
	  
6. 변수 특징

  1) 변수명이 동일하면 안됨
  2) 로컬변수는 사용전에 반드시 초기화
     초기화 안하면 컴파일 에러가 발생됨.

  3) 변수를 인식하는 범위 ( scope )
    ==> 블럭(중괄호{})

7. 상수 ( Constant )
  - 상수는 값 변경 불가
  - final 키워드 이용함.
  - 변수와 구별하기 위해서 대문자로 지정 ( 관례 )
  예> final int NUM=100;


8. 데이터형 변환

  1) 개념
    - 한번 선언된 데이터형은 언제든지 변경이 가능하다.
    - 큰박스에 작은 박스는 저장이 가능하고
      역은 저장불가

  2) 형변환 종류

     (1) 자동 형변환( 묵시적, promotion, up-casting )

         가.  byte(1byte) > short(2byte) > int > long > float > double 
         나.  char(문자형) > int(정수형 )
             예>  int n = 'A';  //가능

	 다. 정수형중에서 int보다 작은 타입의 연산결과는  기본값인 int로 반환된다.
         라. 작은 데이터형과 큰 데이터의 연산결과는 큰 데이터형으로 반환된다.
	    예> 정수형하고 실수형하고 연산결과는 실수형으로 반환된다.

         마. 문자열+비문자열(문자열)=====> 문자열로 반환


     (2) 강제형변환 ( 명시적, type casting, down-casting, 일반적으로 의미하는 형변환 )

         - 작은타입 = 큰타입; //에러

	 - 작은타입 = (작은타입)큰타입;  // 형변환 연산자: (타입)

  3) 현재는 기본형만 형변환 실습을 했음.
     하지만 참조형(클래스)도 형변환이 가능하다. (*************************)
     결론은 자바의 모든 데이터(기본형,참조형)는 형변환이 가능하다.




9. 콘솔(console)에 값을 출력하는 방법
  
   - 출력 대상은 다양하다.
     모니터에 출력하는 경우를 표준출력(standard output) 이라고 한다.
     반대 개념인 표준입력(standard input)은 키보에서 입력받는것을 의미한다.

  1) System.out.println(값); 
    - 새로운 줄(new line)에 출력한다.
    - 반드시 하나의 값만 지정한다.

  2) System.out.print(값);
    - 새로운 줄 없이 현재줄에 출력한다.
    - 반드시 하나의 값만 지정한다.

  3) System.out.printf("  ", ...);  // ... 는 가변인자라고 하고 갯수는 정해져 있지 않음

   예> System.out.printf("  ", 값); 
      System.out.printf("  ", 값1, 값2);
      System.out.printf("  ", 값1,값2,값3,값4,값5);

     String name ="홍길동";
     int age = 20;
     System.out.printf("이름:%s, 나이:%d", name, age);
############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# Java 타입 형변환 원리 & 방법
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%83%80%EC%9E%85-%ED%98%95%EB%B3%80%ED%99%98-%EC%A2%85%EB%A5%98-%EB%B0%A9%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

# final 키워드
https://www.devkuma.com/docs/java/final/
https://sudo-minz.tistory.com/135

# printf(), 이스케이프 문자, 형식 지정자
https://damy.tistory.com/3

# 그림으로 보는 자바 코드의 메모리 영역 (스택 & 힙)
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD%EC%8A%A4%ED%83%9D-%ED%9E%99

############################################################################
############################################################################
2일차 리뷰
1.JDK11 + eclipse2022 설치
  - JDK11 설치후 환경변수 설정
   JAVA_HOME=~
   PATH=~

2. 자바의 데이터 종류

  1) 기본형
       - 수치형
               - 정수형: byte ( 1byte )
	               short ( 2byte )
		        int  ( 4byte ): 기본
			long ( 8byte )
		   리터럴 표현: 10진수, 2진수(0b값), 8진수(0값), 16진수(0x값)
		             long 타입으로 정수값을 표현: 값L
	       - 실수형: float ( 4byte )
	               double  (8byte ): 기본
                   리터럴 표현: 소수점 이용, 지수 표현 가능
		             3.14 ( 3.14D, 3.14d)==> double처리
			     3.14F(3.14f)  ==> float 처리

       - 문자형 : char( 2byte )
                리터럴 표현: '' 이용, 단 하나의 문자 표현시 사용
		          'A', 'a', '홍'
			  escape문자: \t,\n, \', \", \\
	      * 자바언어는 하나의 문자와 여러 문자인 문자열을 구별해서 관리하다.
	        문자열은 참조형인 String 클래스로 관리된다.
       - 논리형 : boolean ( 1btye )
               리터럴 표현: true/false

  2) 참조형

     - 기본형 8개를 제외한 나머지 데이터
     - 클래스, 인터페이스, 배열


3. 변수(variable)
 
 1) 용도: 데이터 저장
 2) 특징: 단 하나의 데이터만 저장 가능
         동일한 이름으로 사용불가 ( 식별불가 )
	 블럭 scope를 따른다. ( 블럭({})안에서 선언된 변수는 블럭안에서만 사용 가능 )
	 * 자바스크립트 언어는 블럭 scope가 아니고 함수 scope를 따른다.

  3) 사용방법

     가. 변수선언 ( 메모리에 데이터를 저장할 영역생성, 영역의 이름을 변수로 지칭)
     나. 초기화
     다. 변수 사용

 4) 변수 종류 3가지

    가. 로컬변수(local variable)
       - 메서드안에서 선언된 변수
       - 생성~소멸: 메서드호출생성~메서드종료시삭제됨. 
       - 사용메모리: stack
       - 변수선언만하고 초기화 안하면 자동으로 초기화가 안됨.
         따라서 변수사용전에 반드시 초기화해야 된다. (*****)
    나. 인스턴스변수(instance variable)
       - 메서드밖에서 선언된 변수
       - 생성~소멸: 클래스 객체생성(new키워드)~ 객체소멸시 삭제됨.
       - 사용메모리: heap
       - 변수선언만하고 초기화 안하면 자동으로 초기화 ( 데이터형의 기본값으로 초기화됨, 정수:0, 실수:0.0 논리:false, 참조형: null )
    다. 클래스 변수 ( class variable, static variable)
      - 메서드밖에서 선언된 변수 + static 키워드
      - 생성~소멸: 프로그램실행시 생성 ~  프로그램 종료시 삭제됨.
      - 사용메모리: method area
      - 변수선언만하고 초기화 안하면 자동으로 초기화  ( 데이터형의 기본값으로 초기화됨, 정수:0, 실수:0.0 논리:false, 참조형: null )

 
4. 데이터 형변환
 
  - 개념: 한 번 정해진 데이터형이 계속 일정하지 않고 필요시 언제든지 변경될 수 있다.
  - 종류
   
    가. 묵시적 형변환( 자동형변환, promotion, up-casting)
        - byte > short > int > long > float > double
        -         char > int
        - int 보다 작은 타입의 연산결과는 int로 반환됨.
	- 작은타입과 큰타입의 연산결과는 큰 타입으로 반환됨.
	- 문자열과 비문자열(문자열)을 + 하면 연결이 됨.
	    
    나. 명시적 형변환( 강제형변환, type casting, down-casting )
      
       - (데이터형)값  형변환 연산자를 사용.
       - 단점은 데이터 손실이 발생될 수 있다.

5. 표준 출력

  - 모니터에 출력
  - 3가지
   System.out.println(값);  // 새로운 라인에 값을 출력
   System.out.print(값);    // 현재 라인에 값을 출력

   System.out.printf("포맷", 값,값2.....);  //   ... 가변인자, 현재 라인에 값을 출력

6. 상수( Constant )
 
  - final 키워드 이용
  - 상수는 값 변경이 불가능.
############################################################################
3일차 ( 3월 12일) 

1. 표준 입력 ( standard input )

  1) 개념: 키보드로 데이터를 입력 받음을 의미

  2) 모니터: System.out
     키보드: System.in

  3) java.util.Scanner 클래스 이용해서 키보드에서 입력된 값을 얻을 수 있다.

     import java.util.Scanner;

     Scanner scn = new Scanner(System.in);

   4) 값을 얻을 수 있는 메서드가 제공된다.

      정수값: int n = scn.nextInt();
      하나의 단어: String s = scn.next();
       예> 키보드 입력: aaa bbb ccc

      한 줄 읽기 : String s = scn.nextLine();



2. 문장 ( statements )

  가. 실행문 :  순차문 : 위에서 아래로 순차적으로 실행되는 문장.
                     거의 90% 이상 차지.

              제어문 :  조건문(분기문) : 조건에 따라서 실행되는 문장이 달라진다.
                                    단일if문, if~else문, 다중if문, switch문

	               반복문 : 조건에 따라서 한번 실행된 문장이 여러번 실행된다.
		                    for문,  while문, do~while문
			   
  나. 비실행문
     - 주석문 : 한줄 주석문 : // 
               멀티 주석문: /*   */
	      javadoc 주석문: /**   */  ==> 개발자가 만든 클래스에 대한 메뉴얼인 API문서 만들때 사용됨.
	                    

  1) 조건문 ( 분기문 )

    가. 단일 if 문
      -용도: 조건식(true/false)에 따라서 실행여부가 결정되는 경우.
      -문법: 
             if(조건식)문장1;
	             문장2;  // 영향이 없음.

             // {} 지정을 권장함.
             if(조건식){문장1;}
	             문장2;

             // {} 역할은 그룹핑 역할.
             if(조건식){
	        문장1;
	        문장2;
	     }
	             

    나. if~else 문
      -용도: 조건식(true/false)에 따라서 실행하는 문장이 달라지는 경우.
      -문법:
             if(조건식)
	        문장2;  // 조건식이 true인 경우에 실행
	     else
	        문장3;  // 조건식이 false인 경우에 실행


            if(조건식){
	        문장2;  // 조건식이 true인 경우에 실행
	     }else{
	        문장3;  // 조건식이 false인 경우에 실행
	     }


     다. 다중 if~else 문
      -용도: 여러번 비교할 때  사용된다.
      -문법:
          
	    if(조건식1){
               문장1;  // 조건? 조건식1이 true인 경우
	    }else if(조건식2){
               문장2;  // 조건? 조건식1은 false, 조건식2는 true
	    }else if(조건식3){
               문장3; // 조건?  조건식1은 false, 조건식2는 false 조건식3는 true
	    }

	     if(조건식1){
               문장1;  // 조건?
	    }else if(조건식2){
               문장2;  // 조건? 
	    }else if(조건식3){
               문장3; // 조건?
	    }else{
               문장4; // 조건? 조건식1은 false, 조건식2는 false 조건식3는 false
	    }

############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
연산자
https://tadaktadak-it.tistory.com/7
https://hongong.hanbit.co.kr/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%97%B0%EC%82%B0%EC%9D%98-%EB%B0%A9%ED%96%A5%EA%B3%BC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/

# 자바 제어문
https://raccoonjy.tistory.com/10
############################################################################
############################################################################
    참조형 데이터
교재 p177 - 배열
    p128 - 객체와 클래스
############################################################################
3일차 리뷰

1. 연산자 (Operator)

  1) 산술연산자
     + ( 수치데이터 이용하면 연산은 더하기로 처리됨. 
         문자열과 다른값(문자열,비문자열)을 + 하면 연결되어 반환됨
	  예> System.out.println("홍길동 "+20 );
	 )
     -
     *
     / (정수값으로 나누기하면 결과값은 정수값으로 반환. 10/3=>3, 10/3.0=3.3333333 )
     % (나머지)

  2) 대입연산자
    용도: 변수에 임의의 값을 저장(할당,대입)하는 역할.
     
     a=b;  // a에 b를 저장(할당,대입)함.
     a+=b; // 풀어쓰면 a=a+b; 동일
     a-=b; // 풀어쓰면 a=a-b; 동일
     a*=b; // 풀어쓰면 a=a*b; 동일
     a/=b; // 풀어쓰면 a=a/b; 동일
     a%=b; // 풀어쓰면 a=a%b; 동일

   예> 새로운 변수 m을 선언하고 n 변수에 저장된 값을 저장하시오.
      int n = 10;
      int m = n;
      n=20;

   3) 비교연산자
     용도: 값(기본형)을 비교하는 기능. 실행결과는 논리값(true/false) 반환됨.
          ( 참조형은 클래스,인터페이스,배열은 비교연산자를 사용할 경우가 거의 없다. )
     a==b;  // a와 b가 같냐?
     a!=b;  // a와 b가 같지 않냐?
     a>b;   // a가 b보다 크냐?
     a>=b;  // a가 b보다 크거나 같냐?
     a<b;   // a가 b보다 작냐?
     a<=b;  // a가 b보다 작거나 같냐?
      ( 자바스크립트에서는  ===, !== 추가됨 )

    4)논리 연산자
      용도:  논리값(true/false)을 이용해서 연산하는 기능.  실행결과는 논리값(true/false) 반환됨.

      && : 논리값1 && 논리값2  ==> 논리값1 과 논리값2 가 모두 true인 경우에만 최종적으로 true가 반환됨.
           '그리고(and)' 로 해석.

      || : 논리값1 || 논리값2 ==> 논리값1 과 논리값2 중에 하나라도 true인 경우에 최종적으로 true가 반환됨.
           '또는(or)' 로 해석.

      !  : !논리값  ==> 논리값이 true면 false로  false면 true로 반환됨.
           부정연산자라고도 부른다.

      * short circuit logical 연산자
        ==> &&또는 || 연산자 앞의 논리값만 확인해서 최종적인 결과가 반환되는 메커니즘.

    5) 비트 연산자
      &
      |
      ^
      ~

    6) 증감연산자 ( 증가 연산자와 감소 연산자 )
      용도:  임의의 변수값을 1씩 증가하거나 1씩 감소하는 기능

      문법:  ++변수명;  // 전치
            변수명++;  // 후치  

	    --변수명:  // 전치
	    변수명--;  // 후치

	   ==> 위와 같이 다른 연산자 없이 독자적으로 사용하는 경우에는
	      전치 및 후치 결과는 같다.

	   변수명2 = ++변수명1;  // 전치,  먼저 증가하고 나중에 할당
	   
	   변수명2 = 변수명1++;  // 후치,  먼저 할당하고 나중에 증가

	  ==> 위와 같이 다른 연산자와 같이 사용하는 경우에는
	      전치 및 후치 결과에 따라서 변수명2의 값이 달라질수 있다.

     7) 3항 연산자
       용도: 조건을 이용해서 임의의 값을 얻을 때 사용
       문법:
            변수명 = (조건식)?참문장:거짓문장;

       특징: 중첩이 가능.
            if~else문과 비슷한 기능.

  
2. 표준입력
 개념: 키보드로부터 임의의 데이터를 입력 받음을 의미
 문법:
      import java.util.Scanner;

      Scanner scan = new Scanner(System.in);

      int num = scan.nextInt();
      String s = scan.next();    // 하나의 단어
      String s = scan.nextLine(); // 한 줄
############################################################################
4일차 ( 3월 13일 )

1. 문장 (statement )

  가. 실행문
      - 순차문
        : 위에서부터 아래로 순차적으로 실행되는 문장
        : 대부분의 문장에 해당, ;(세미콜론) 끝남

      - 제어문
        : 조건에 따라서 실행되는 문장이 달라지거나 또는 반복될 수 있는 문장
	 - 조건문(분기문) : 단일 if문 : 특정문장을 조건에 따라서 실행여부가 결정되는 경우.
	                 if~else문: 조건에 따라서 실행되는 문장이 다른 경우.
			 다중 if문:  조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자는 다양하다.
			 switch문:  조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자 지정안함.
			            (내부적으로 == 만 사용)
				    break문 사용가능

	 - 반복문 :  for문
	            while문
                   do~while문
	        * 반복문에서 사용되는 2가지 키워드
		  - break문
		  - continue문

  나. 비실행문
      - 주석문
      - 한줄 주석: //
        멀티 주석: /* */
	javadoc주석: /** */


2. 조건문: 단일 if문

 용도: 특정문장을 조건에 따라서 실행여부가 결정되는 경우.
 문법:
     1) {}(블럭) 지정 안한 경우 ( 권장안함 )
	     // if조건식에 영향을 받는 문장은 문장1 만 해당됨. ( 문장2는 영향이 없음)
	     // 조건식이 true인 경우는 문장1이 실행되고 false면 실행 안됨.
	     if(조건식) 문장1;
	              문장2;

     2) {}(블럭) 지정한 경우 ( 권장함 )

           if(조건식){
	      문장1:
	   }	      
	   문장2;


3. 조건문: if~else문

 용도: 조건에 따라서 실행되는 문장이 다른 경우.
 문법:

   1) {}(블럭) 지정 안한 경우 ( 권장안함 )
      - 조건식이 true이면 if블럭인 문장1 실행되고 false이면 else블럭인 문장2가 실행된다.
      if(조건식)
         문장1;
      else
         문장2;

   2) {}(블럭) 지정한 경우 ( 권장함 )

      if(조건식){
         문장1;
      }else{
         문장2;
      }

4. 조건문: 다중 if문

 용도: 조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자는 다양하다.
      
 문법: 

     1) {}(블럭) 지정한 경우 ( 권장함 )

      if(조건식1){
         문장1;
      }else if(조건식2){
         문장2;
      }else if(조건식3){
         문장3;
      }

 특징: 조건식에 사용될 수 있는 연산자는 다양하다.

5. 변수 scope 
 개념: 자바의 변수는 기본적으로 블럭scope를 따른다.
      블럭({})안에서 선언된 변수는 블럭안에서만 사용할 수 있고
      블럭밖에서 사용이 불가능하다.
 
    main(){

      int num= 10; //로컬변수
      if(true){
         System.out.println(num);
         int num2 = 20; //로컬변수
         System.out.println(num2); 
      }
      System.out.println(num);
      System.out.println(num2);  //에러 발생
    }//end main

6. switch문
  용도: 조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자 지정안함.
      (내부적으로 == 만 사용)
  특징: break문 사용 및 미사용 가능하다. (옵션기능)
       ==> break문이 없으면 일치된 case 문 이후의 모든 문장이 실행된다.
       switch문에 사용되는 변수의 데이터 타입은 6가지만 가능하다.
       ( byte,short,int, char, String, enum )
       case 문에는 중복값 지정 불가
  문법:
       switch(변수){
	  case 값1(리터럴): 문장;
	                 break;	// switch문을 빠져나옴.
          case 값2(리터럴): 문장;
	                 break;	// switch문을 빠져나옴.
          ..
	  default: 문장;
       }

7. 반복문
 
 예>   Hello 5번 출력하시오.

  횟수:
   1   Hello 출력
   2   Hello 출력
   3   Hello 출력 
   4   Hello 출력
   5   Hello 출력
   6   중단
  
   10
   8
   6
   4
   2

 필요한 3가지 요소
 1) 시작값 필요 : 1 ==> 변수사용 
    int n=1;
 2) 증가/감소 연산 필요: ==> 연산자 이용 
    1씩증가/감소: ++n,  --n
    2씩증가/감소: n=n+2; n=n-2; 
                n+=2;  n-=2;
 3) 값비교하는 연산 필요: ==> 조건식
     n<6


  1) for문 ( 반복회수 예측이 쉽게 가능한 경우 )
  문법;
       for(시작값(초기값); 조건식; 증감연산자){
           문장1;
	   문장2;
       }

   예> for(int n=1;n<6;++n){
         System.out.println("hello");
      }

  *주의: 
    위 3가지 구성요소(시작값,조건식,증감연산자)가 
    하나라도 빠지면 원하는 반복이 안 될수 있다.
    무한루프에 빠질수 있다.


  2) while 문 ( 반복회수 예측이 어렵거나 또는 무한루프 )
   - 반드시 3가지 구성요소(시작값,조건식,증감연산자)가 필요하다.
   -문법:

        시작값;
        ..
       while(조건식){
            문장;
	증감연산자;
       }

   //무한루프
    while(true){

    }

  3) do~while문
  - 반드시 3가지 구성요소(시작값,조건식,증감연산자)가 필요하다.

  문법:

       시작값;
       do{
         
	 문장;
	 증감연산자;
       }while(조건식);

   특징: while문은 조건이 처음부터 false라면 한번도 문장이 실행되지 않는다.
   하지만 do~while 문은 나중에 조건식이 실행되기 때문에 조건이 처음부터 false라도 반드시 1번은 문장이 실행된다.
   
   결론은 조건과 무관하게 무조건 1번은 실행해야되는 경우라면 do~while문을 사용한다.


8. break문, continue문
 
  1) break문
   용도:  반복문을 빠져나올때 사용.
   문법:
         if(조건식)break;

        for(int n=1; n <= 5; n++ ){
	      //n값이 3일때 중단
              if(n==3)break; //1128라인으로 점프
              System.out.println("hello");
	}

        System.out.println("END");

    
  2) continue 문
   용도: 반복해야되는 여러 문장들중 특정문장들을 특정회차에서 skip할 때 사용.
   문법:
         if(조건식)continue;

	for(int n=1; n <= 5; n++ ){
	   if(n==3)continue;  // 1141라인으로 점프. 반복문의 끝(})으로 ...
           System.out.println("hello" + n);
	}

        System.out.println("END");



--------------------------
 * 자바에서 데이터 저장방법 3가지 (외우기)
 1) 변수(variable)
    - 값(데이터) 하나만 저장이 가능
    - 데이터 개수만큼 변수가 필요하다.
      관리가 어렵다.
    - 저장되는 값이 기본형: 기본형 변수
      저장되는 값이 참조형(클래스,배열,인터페이스): 참조형 변수

 2) 배열(array)
    - 여러개의 값(데이터)을 저장이 가능.
    - 배열에 저장하는 데이터형은 동일해야 된다.
    - 크기변경이 불가
    - 배열자체는 참조형이고 저장되는 데이터는 기본형 및 참조형도 가능하다.

 3) 컬렉션 ( Collection API )
    - 여러개의 값(데이터)을 저장이 가능.
    - 컬렉션에 저장하는 데이터형은 달라도 무관.
    - 크기변경이 자동.
    - 컬렉션자체는 참조형이고 저장되는 데이터는 참조형만 가능하다. ( 기본형은 wrapper클래스를 이용해서 저장가능)
    - 종류 3가지 ( 클래스로 제공 )
    (1) List 계열
        - 저장순서가 있음. 중복이 가능하다.
    (2) Set 계열
        - 저장순서가 없음. 중복이 불가(1번만 저장됨)
    (3) Map 계열
        - name(key)와 value(값) 을 쌍으로 저장
	- 순서가 없음.
	- 동일한 name(key)은 저장하면 값을 덮어쓴다.
--------------------------

9. 배열(array)

 용도: 데이터 저장
 특징: 참조형 데이터이다. 
      참조형인 배열은 반드시 저장영역을 만들 때 new 이용한다. (********************)
      저장되는 메모리는 heap이다.
      한번 생성된 배열은 크기 변경이 불가능하다. ( 크기를 늘리고 싶으면 배열을 다시 new 해야 된다. )
      배열에 저장되는 데이터는 기본형 및 참조형 모두 가능하다.
      1차원 및 다차원 배열 생성이 가능하다.

 사용방법:
    1) 배열 선언
    문법: 데이터형 [] 배열명;   // 배열명은 변수명과 동일

        // 기본형인 int 저장용
        int [] num;   or  int num [];

      * 구별해야 되는 것
        int num;  // num 의 데이터타입? int, 기본형
	             num에 저장될 수 있는 값? int인 정수

	int [] num2;  // num2 의 데이터타입? int [], 참조형
                         num2 에 저장될 수 있는 값? 주소값

   2)  배열생성 ( new 이용 )

     문법: 배열명 = new 데이터타입[크기];

          num = new int[3];  // 크기 3을 가진 배열이 heap 메모리에 생성된다.
	                     // heap에 생성되기 때문에 자동초기화가 된다.

   3) 배열요소접근
    문법: 생성된 배열의 인덱스(첨자) 사용해서 접근한다.
         인덱스는 0부터 시작한다. 배열길이보다 항상 1이 작다. 
	 배열길이: 배열명.length

	 배열명[인덱스];

	 System.out.println(num[0]);
	 System.out.println(num[1]);
	 System.out.println(num[2]);
         //System.out.println(num[3]); // 없는 요소 접근시 예외 발생됨. java.lang.ArrayIndexOutOfBoundsException
	 System.out.println(num.length)


    4) 배열요소 접근 방법

       가. 직접 인덱스 지정
         예> num[0]
	  ==> 접근할 요소가 많으면 비효율적임.

       나. (일반) for문 이용
         예>
	    for(int idx=0; idx < num.length; idx++){
               System.out.println( num[idx] );
	    }
	  ==> 단점은 조건을 잘못 지정하면 예외가 발생된다.
	   
       다. 향상된 for문 ( foreach 문 )

          문법: 
	        for(변수: 배열명 ){

		}

         예>  for( int n : num ){
		 System.out.println(n);
	      }


10. new 이용한 방법 이외의 방법 2가지 살펴보기
 
    1) new 이용
      예> int [] num;
          num = new int[3];
          num[0]=10;
	  num[1]=20;
	  num[2]=30;

    2) 리터럴(값) 이용 ( ************ )
    문법:
          데이터형 [] 배열명 = { 값, 값2, 값3,....  };
     
      예> int [] num = {10, 20, 30};

    특징: 한번에 구현해야 된다.

         int [] num;
	  num = {10, 20, 30}; // 에러 발생

    3) new + 리터럴 혼합 형태 ( *********)

    문법:
          데이터형 [] 배열명;
	  배열명= new 데이터형[]{ 값, 값2, 값3,....  };
     
      예> int [] num;
          num = new int[]{10, 20, 30};
############################################################################
4일차 리뷰
1.제어문

  1) 조건문(분기문)
   
      - 단일if문 : 조건식에 따라서 실행여부가 결정됨.
         문법:
	       if(조건식){
                  문장1;
		  문장2;
		  ..
	       }
  
      - if~else문: 조건식에 따라서 실행되는 문장이 달라지는 경우에 사용됨. 
         문법:
	       if(조건식){
                  //조건식이 true인 경우에 실행
	       }else{
                  //조건식이 false인 경우에 실행 
	       }

      -조건식이 여러개
         가) 다중 if문
            - 명시적으로 연산자를 지정함. 예> ==, > , >= ,....
	    문법:
	         if(조건식1){

		 }else if(조건식2){

		 }else if(조건식3){

		 }

	 나) switch문
	    - 명시적으로 연산자를 사용안함.
	      묵시적으로 == (동등연산자) 사용함.
            문법:
	         switch(변수){
                   case 값1: 문장1; break;
                   case 값2: 문장2; break;
		   ..
		   default: 문장n;
		 }
            - break문은 옵션.
	    - switch문에서 사용 가능한 데이터 타입은 6개이다.
	      ( byte,short,int, char, String, enum )

    ==> 변수scope는 블럭scope를 따른다.
       즉 블럭({})내에서 선언된 변수는 블럭안에서 사용이 가능하다. 

  2) 반복문
     - 구성요소 3가지 
        가. 시작값(초기값)
	   예> 1 0 10
	나. 조건식
	   예> n < 5
	다. 증감식

     - 종류

     가. for문
       문법:
           for( 초기값 ; 조건식  ; 증감식 ){

	   }
       -용도: 반복횟수 예측이 가능한 경우에 사용됨.

     나. while문
       문법:
            초기값;
            while(조건식){
                문장;
		증감식;
	    }
        -용도: 반복횟수 예측이 힘든 경우 ( 무한루프 )
	-특징: 조건식값에 따라서 문장이 한번도 실행안될수도 있다.

     다. do~while문
        문법:
             초기값; 
	     do{
                문장;
		증감식;
	     }while(조건식);
	 -용도: 반복횟수 예측이 힘든 경우
	 -특징: 조건식값에 따라서 문장이 적어도 한 번은 실행될 수 있다.


2. 배열(array)

  1) 자바에서 데이터를 저장할 수 있는 3가지 방법 (외우기)
    가. 변수
      - 단 하나의 값만 저장이 가능하다.
      - 값의 종류는 기본형 및 참조형 모두 가능.
          예>  기본형 변수 : n변수에 가면 10(실제값)이 저장되어 있음.
	      int n = 10; // n 변수의 데이터타입은 ? 기본형데이터타입, int 타입

	      참조형 변수 : name 변수에 가면 "홍길동"이 저장된 주소값이 저장되어 있음.
	      String name =  "홍길동";  // name 변수의 데이터타입은?  참조형 데이터타입, String 타입

    나. 배열 ( 참조형이다.)
      - 여러개의 값 저장 가능. 단, 동일한 데이터형만 가능.
      - 값의 종류는 기본형 및 참조형 모두 가능.
        예>
	   기본형 배열: num 변수에 가면 10,20,30 이 저장된 배열의 주소값이 저장되어 있음.
	   int [] num = { 10,20,30}; // num 변수의 데이터타입은 ? 배열타입, 참조형 데이터타입, int형의 배열타입

           참조형 배열: name 변수에 가면 "홍길동","이순신" 이 저장된 배열의 주소값이 저장되어 있음.
	   String [] name = { "홍길동","이순신" };// name 변수의 데이터타입은 ? 배열타입, 참조형 데이터타입, String 형의 배열타입
 
    다. 컬렉션 ( 참조형이다.)
      - 여러개의 값 저장 가능. 데이터타입이 달라도 가능.
      - 값의 종류는 참조형만 가능하다. (기본형은 wrapper 클래스형태로 저장가능 )

      기본형          wrapper 클래스
      ----------------------------
      byte		Byte
      short		Short
      int		Integer
      long		Long
      float		Float
      double		Double
      char		Character
      boolean		Boolean

 2) 1차원 배열 생성 방법

   가. new 이용
      문법;
           데이터타입 []  변수(배열명);
	   변수 = new 데이터타입[size];
           배열명[idx];

	   배열명.length;

   나. 리터럴 이용
      문법:
             데이터타입 []  변수(배열명) = { 값, 값2, ... }; // 반드시 한 라인에 생성해야 된다.
             배열명[idx];
             배열명.length;

   다. new + 리터럴 혼합
       문법:
            데이터타입 []  변수(배열명);
	    변수 = new 데이터타입[]{ 값, 값2, ... }; // 명시적으로 size지정 불가

	    배열명[idx];
	    배열명.length;
 
  3) 배열 순회 방법

    가. 일반 for문 
        int [] num = {10,20,30};     
      
        for(int idx=0; idx < num.length; idx++){
            System.out.println( num[idx]);
	}

    나. foreach 문 ( 향상된 for문 )
       int [] num = {10,20,30};  

       for(int n : num ){
          System.out.println(n);
       }
###################################################################
5일차 ( 3월 14일 )

1. 2차원 배열
  
  1) 정방형
    가. new 이용
        데이터타입 [][] 배열명 = new 데이터타입[행크기][열크기];

    나. 리터럴 이용
        데이터타입 [][] 배열명 = { { 값1, 값2 }, { 값1, 값2}, {값1, 값2} }; 
    
    다. new + 리터럴 혼합
        데이터타입 [][] 배열명 = new 데이터타입[][] { { 값1, 값2 }, { 값1, 값2}, {값1, 값2} }; 
  
  2) 비정방형
     가. new 이용 ( 행크기만 지정 )
        데이터타입 [][] 배열명 = new 데이터타입[행크기][];
         // 열은 나중에 생성
	 배열명[0]=new int[열크기];

    나. 리터럴 이용
        데이터타입 [][] 배열명 = { { 값1 }, { 값1, 값2, 값3}, {값1, 값2} }; 
    
    다. new + 리터럴 혼합
        데이터타입 [][] 배열명 = new 데이터타입[][] { { 값1 }, { 값1, 값2, 값3}, {값1, 값2} }; 
    

2. 커맨드 라인 아규먼트 배열 ( command line arguments )

   1) public static void main( String [] args ){}

      - 모든 메서드는 기본적으로 파라미터 가질수 있다.
        파라미터(parameter): 메서드명( 변수, 변수2,... ){ 로컬변수}
      - 파라미터는 로컬변수에 속함. 따라서 stack 저장됨.
      - 아큐먼트(arguments, 인자값)는 파라미터(변수)에 저장되는 값을 의미한다.


   2) 실행할 때 값을 설정할 수 있다. 

      예> Hello.java
                   <== c:\> javac Hello.java 
         Hello.class
	           <== c:\> java Hello  10 20 


   3) 이클립스에서 arguments(인자값) 설정하는  방법

     *.java 선택하고 오른쪽클릭 > Run as > Run configuration > arguments 탭에
       공백을 구분자로 값을 설정 > Run 선택.

3. 문자열 형태의 정수인 "10" 값을 실제 정수로 변경하는 방법
    "10"===> 10
   예> int num = Integer.parseInt("10"); // num에는 정수 10이 저장됨.


4. 랜덤값 얻기
  - java.util.Random 클래스 이용

  - 방법
   1) Random 클래스 객체 생성
      
       import java.util.Random;

       Random r = new Random();

   2) 랜덤값 반환하는 메서드 사용

      int n = r.nextInt();
      int n2 = r.nextInt(3); // 0, 1, 2 중에서 랜덤하게 반환
      float f = r.nextFloat(); 
      double d = r.nextDouble();
      boolean b = r.nextBoolean(); 
#######################################################
5. 클래스

  1) 객체(object) ?
    - 주체(subject)가 눈으로 보여지는 사물의미.
     예> 모니터 객체, 
        노트북 객체,
	책상 객체,
	학생 객체,....
  2) 객체(object)의 구성요소 2가지
     예> 학생객체
     가. 속성
        - 객체를 표현할 수 있는 특성
        - 예> 학번, 이름, 전화번호, 주소, ....
	
     나. 동작(기능)
         - 객체의 행위.
	 - 예> 등교하기, 공부하기, 하교하기,... 졸기(X)
 
   3) 객체지향 프로그래밍 ( Object Oriented Programming: OOP )
    - 현실세계에 존재하는 속성과 동작 구성요소로 되어있는
      객체(object)라는 개념을 이용해서 프로그래밍하는 방법론.
    - 대표적 언어: 자바

   4) 자바에서는 객체(object)를 어떻게 표현할까? (***************)

    현실세계             OOP               가상세계(자바 프로그래밍)
    ------                            --------------------
    고양이 객체    --------------------------> 클래스로 표현 ( Cat 클래스 )
    -속성: 이름,나이,성별... ------------------> 변수로 표현 (인스턴스 변수)
    -동작(기능):먹기,뛰기,... -----------------> 메서드로 표현

   5) 만들어지 클래스 사용할려면 ?

     - 반드시 클래스를 사용할려면 객체생성해야 된다. (********************)
     - 객체생성은 new 키워드 이용
     문법:
           클래스명  변수명 = new 클래스명(); ( 외우기 )
      예> 

          main(){
	    Cat c = new Cat(); 
          }

        1번: Cat c 수행
	    - c 가 로컬변수 ( stack 저장 )
	           참조변수 ( 주소값 저장, 참조하면 Cat이 있음 )
		   Cat 타입의 변수

         2번:  new Cat 수행
	    -  heap 메모리에 Cat 을 생성.
	    -  heap 메모리에 생성된 Cat을 인스턴스(instance)라고 부른다.
	       인스턴스안에 있는 구성요소인 변수와 메서드를 멤버(member)라고 부른다.
	    -  heap 메모리에 생성된 변수를 인스턴스 변수(멤버변수)라고 한다.
            -  heap 메모리에 생성된 메서드를 인스턴스 메서드(멤버메서드)라고 한다. 

        3번: Cat()
	    - 생성자 호출하는 코드이다.

         4번: =
	    - heap 메모리에 생성된 Cat 인스턴스 주소값을 
	      c에 할당한다.
	    - 이후에 Cat 인스턴스의 구성요소(변수,메서드)를 접근하기 위해서는
	      c 참조변수를 이용한다.
	      방법: c.변수/c.메서드()
################################################################
6. Cat 클래스 작성

  1) 특징
     - 현실세계의 고양이 객체를 추출하고 
       자바언어로 프로그래밍하기 위해서 만든 클래스이다.
     - 2가지 구성요소를 가짐 (변수와 메서드 )
       변수는 현실세계의 고양이 객체의 속성을 표현하기 위함.
       메서드는 현실세계의 고양이 객체의 기능(동작)을 표현하기 위함.

     - 주의할 점은 main 메서드를 지정하지 않는다. (*************)
       이유는 재사용하기 위함이다. ( 클래스 재사용 )
       main메서드가 없기 때문에 실행이 안됨.
       실행하기 위해서 main메서드를 가진 임의의 클래스(핸들링 클래스)를 추가해야 된다.

      결론:
            Cat 클래스 (main 없음)

	    TestCat 클래스 ( main 있음, Cat 핸들링 역할: 객체생성등.... )
############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# 자바 참조 타입 - 배열
   https://kephilab.tistory.com/37
# java new
  https://yoo11052.tistory.com/52
# 배열 선언 및 초기화 방법 정리
   https://non-stop.tistory.com/3
# 2차원 배열과 동적할당
   https://jwj1699.tistory.com/3
#  다차원 배열(2차원 배열)
   https://ococ99.tistory.com/38
# Java main Argument 관련 자료
   https://velog.io/@98kimjh/Java-Main-Arguments
   https://storyjava.tistory.com/171
   https://skillazit.tistory.com/2
# 객체 지향 프로그래밍 개념
  https://victorydntmd.tistory.com/117
# 클래스 및 객체 생성과 사용법
  https://kadosholy.tistory.com/89
  https://sime.tistory.com/41
# 객체 생성과 참조 변수 / this
   https://we1cometomeanings.tistory.com/6
############################################################################
############################################################################
############################################################################          
5일차 리뷰
1. 배열(array)

  용도: 같은 타입의 데이터를 여러개 저장가능한 방법.
  특징: 같은 타입만 저장 가능.
       한번 생성된 배열은 크기변경이 불가. ( 크기변경할려면 다시 생성해야 된다.)
       배열은 참조형( 배열명(변수)는 주소값을 갖는다. )
       배열에 데이터는 기본형 데이터(8개)도 가능하고 참조형 데이터(클래스)도 가능하다.
       배열의 요소접근은 인덱스(첨자)를 이용하고 0부터 시작한다. 예>  배열명[idx]
       배열의 길이는 배열명.length 를 사용한다.

   사용방법: 
     1) 배열선언
       데이터타입 [] 배열명;  // 배열명의 데이터타입은 ( 데이터타입 [] ), 참조형이기 때문에 주소값을 갖는다.
       데이터타입 배열명 [] ;

     2) 배열생성 ( new )
       배열명 = new 데이터타입[size];  // 생성된 배열이 heap 메모리에 생성됨. heap 메모리에 생성된 변수는 자동초기화됨.

     3) 배열초기화 // 인덱스를 이용, 0부터 사용가능
       배열명[idx]=값;

     4) 배열크기
       배열명.length;

    배열생성 3가지 방법
      1) new 이용
         int [] num;
	 num = new int[3];
	 num[0]=10;
	 num[1]=20;
	 num[2]=30;

      2) 리터럴 이용
         int [] num = {10,20,30};
   
      3) new + 리터럴 이용
         int [] num;
	 num = new int[]{10,20,30};

2. 2차원배열 ( 다중행/다중열 로 구성 )

   1) 정방형배열 ( 모든행의 열의 길이가 동일. 특징은 하나의 new로 행과 열을 동시에 생성.
      가. new 이용
          int [][] num;
	  num = new int[2][2]; // new int[행크기][열크기] 2X2
	
	  num[0][0]=10;
          num[0][1]=20;
	  num[1][0]=30;
	  num[1][1]=40;

	  행의길이: num.length
	  1행의 열길이: num[0].length

      나. 리터럴 이용
          int [][] num = { {10,20},{30,40}};

      다. new + 리터럴 이용
          int [][] num = new int[][]{ {10,20},{30,40}};

   2) 비정방형배열 ( 행의 열의 길이가 다르다. 특징은 하나의 new 로 행을 만들고 여러번의  new로 열을  생성 )

      가. new 이용
          int [][] num;
	  num = new int[2][];  // 행부터 생성

	  //나중에 열을 만듬
	  num[0]=new int[1];
	  num[1]=new int[3];

          //배열초기화
	  num[0][0]=10;
	  num[1][0]=20;
	  num[1][1]=30;
	  num[1][2]=40;

      나. 리터럴 이용
          int [][] num = { { 10 },{20,30,40}};

      다. new + 리터럴 이용
         int [][] num = new int[][]{ {10},{20,30,40}};

    =====> 배열 사용시 Arrays 클래스의 도움을 받으면 배열처리를 손쉽게 할 수 있다.


3. Integer.parseInt("10")
  역할: "10" 는 연산불가.
       연산하기 위해서 "10" 를 10로 변경해야 된다.
       예>  int num = Integer.parseInt("10");
           float f = Float.parseFloat("3.14");

4. 랜덤값 얻기
   - java.util.Random 클래스 이용
   - 사용방법:
       
       Random r  = new Random(); // Random의 구성요소 ( 변수와 메서드 )

       r.nextInt()
       r.nextInt(n)
       r.nextFloat()
       ..

5. 클래스
 
 가. 객체(object)
    정의: 현실세계의 존재하는 사물의미.
         만약에 A 동물병원에서 '애완동물 관리'하는 프로그램 개발 의뢰를 받았음.
	 주문(order)---> 분석 ---> 설계----->구현 -----> 테스트 -----> 배포
	 분석단계의 핵심작업: 애완동물관리 프로그램에 적합한 객체(object)를 추출.
	                 예> 고양이객체(속성과동작), 강아지객체(속성과동작)

 나. 클래스(class)
    정의: 분석단계에서 추출한 고양이 객체(속성과동작)를 자바에서 표현하는 방법.
        고양이객체 ---------------------> 고양이클래스인 Cat
	속성     --------------------->  인스턴스변수
	동작     ----------------------> 메서드

	public class Cat{
           //속성인 인스턴스 변수
	   String name;
	   int age;
	   String gender;

	   //동작인 메서드
	}

 다. 인스턴스(instance)
    정의: 2마리 관리한다고 가정
         예> 야옹이 2 암컷 ,   망치 1 수컷

	 main(){

	 Cat c1 = new Cat();
	 c1.name="야옹이";
	 c1.age=2;
	 c1.gender="암컷";


         Cat c2 = new Cat();
	 c2.name="망치";
	 c2.age=12;
	 c2.gender="수컷"; 

	 
#############################################################################
6일차 (3월 15일 )
0. 클래스 문법:
    접근지정자 class 클래스명{
    
    }
    
    2. 클래스명 
     - 사용자 정의 식별자
     - 반드시 첫글자는 대문자
     - 의미있는 명사형
     
    3. 클래스 구성요소
      - 변수(멤버, 멤버변수, 인스턴스 변수)
      - 메서드(멤버, 멤버메서드)
      - 생성자(constructor): 멤버에 포함안됨.
      
    4. 클래스 사용
      - 반드시 객체 생성해야 된다.
        객체 생성 작업을 '인스턴스화' 한다고 함.
      - new 이용. 생성된 클래스는 heap메모리에 인스턴스로 생성됨.
      - 문법:
         
           클래스명  변수명 =  new 클래스명([값,값2,..]);
           
1. 생성자 ( constructor )

  역할: heap메모리에 생성된 인스턴스내의 인스턴스 변수를 초기화하는 역할.
       인스턴스를 직접 접근할수도 있으나 권장안함.
       이유는 잘못된 데이터를 필터링없이 저장이 가능하기 때문이다.
       예> c1.age=2000;  // 논리적으로 문제가 있음.
       
  문법:
        public 클래스명([변수,변수,...]){
            // 인스턴스 변수초기화
	}

  특징:
     - 생성자가 수행이 될려면 반드시 생성자를 호출해야 된다.
       호출방법: 
                new Cat();  // Cat() 코드가 생성자를 호출하는 코드이다.

      - 생성자는 명시적으로 지정할 수도 있고 자동으로 지정될 수 있다.
        자동으로 지정되는 생성자의 형식은 다음과 같다. ( 기본생성자, default 생성자 라고 부른다. )
	   public 클래스명(){

	   }
        단, 명시적으로 생성자를 지정하면 기본생성자는 생성안됨. 
	이유는 기본생성자로 new 하지 말고  명시적으로 지정한 생성자로 new 하라는 의미이다.
	필요시 기본생성자를 명시적으로 지정할 수 있다.
      - 필요시 생성자를 여러개 지정할 수 있다.
        식별이 가능하기 위해서 반드시 생성자([파라미터,...])의 파라미터인 인자리스트는 달라야 된다..
	argument list(인자리스트)는 갯수 또는 타입 또는 순서가 달라야 된다.
        이렇게 하나의 클래스에 여러개의 생성자를 지정할 수 있고 이것을 '오버로딩(overloading) 생성자'라고 부른다.

      - 생성자이용한 초기화 장점 2가지
        1) 생성자안에서 값의 유효성체크가 가능하다.
	2) 직접접근한 방법보다 훨씬 빠르게 초기화가 가능하다.

      - 오버로딩 생성자 지원하는 이유?
        사용자가 모든 인스턴스변수의 값을 알고 있지 못한 경우도 있다.
	따라서 알고있는 값만 초기화하는 역할의 오버로딩 생성자가 필요하다.

      - 이클립스에서 오버로딩 생성자 코드를 자동으로 추가할수 있게 지원됨.

2. 지정자(modifier)

   1) 접근지정자 ( access modifier  )
     ==> 순서중요
      
       public : 제한이 없음.
       protected
                (default)
       private: 외부클래스에서는 접근이 불가능. 내부(자신)에서는 접근가능.

    ==> 접근지정자 사용가능한 경우
        -클래스
        -메서드
	-로컬변수 제외한 인스턴스 변수 및 클래스변수에 사용 가능
        -생성자

   2) 일반지정자 ( standard modifier)
    - static
    - final
    - abstract
    - transient,..

3. this 키워드

  1) 개념: heap 메모리에 올라간 인스턴스 자신의 주소를 참조한다.
       this는 생략할 수 있다.

  2) 반드시 명시적으로 this를 지정해야 되는 경우가 있음.
    ==> 인스턴스변수명과 메서드및생성자의 파라미터변수명이 동일한 경우이다.
        문법: this.변수, this.메서드();
      예>  
          public class Cat{

              String name; //인스턴스변수
	    
	   public Cat( String name ){ // 로컬변수(파라미터)
                this.name = name;
	   }

     ==> 생성자에서 다른 생성자를 호출할 때
        문법: this([값,값2,..]);
	 예> this(); ==>  Cat() 호출
	    this("야옹이",2) ==>  Cat(String name, int age) 호출
            this("야옹이",2, "암컷") ==>  Cat(String name, int age , String gender) 호출 
        
	주의: 반드시 생성자 첫라인에서 지정해야 된다.

       예> public Cat(String name, int age, String gender) {
		this.name = name;
		this.age = age;
		this.gender = gender;
	  }
	  public Cat(String name, int age) {
	       this(name, age, "암컷") ;
	  }


4. 메서드(method)

  1)클래스 구성요소 역할
   
     public class Cat{

          // 인스턴스 변수: 객체의 속성을 저장하는 용도. this.변수 가능.(일반적으로 this생략)
	                 직접 접근 방지 위해서 private로 지정한다.
          private  int age;

	  // 생성자 : 인스턴스 변수의 초기화 용도. 오버로딩(overloading 가능 ), this(값,..) 이용해서
	             다른 생성자도 호출가능.
          public Cat(int age){
             this.age = age;
	  }

	  // 메서드 : 다양한 기능처리 용도.
	            지금은 age라는 인스턴스 변수를 수정 또는 조회하는 역할로 메서드를 작성할 것이다.
     }

   2) 메서드 문법

     문법:
           // 메서드
           public 리턴타입 메서드명([변수,변수,..]){
	       문장1;
	       문장2;
	       [return 값;] //리턴값
	   }

	   // 생성자
	   public 클래스명([변수,변수,...]){
               문장1;
	   }

    생성자와 차이점: - 리턴타입을 반드시 지정해야 된다.
                 - 리턴값을 가질수 있다.
		 - 메서드명은 임의로 지정 가능 ( 생성자는 반드시 클래스명으로 지정해야 된다. )

    생성자와 공통점: 반드시 호출해야 된다.
               
	       가. 생성자 호출 방법
		  a. 다른 클래스에서 호출
		     - new 클래스명([값,값...]);

		  b. 자신이 호출
                     - this([값,값...]);

	       나. 메서드 호출 방법
                  - 인스턴스 변수와 (인스턴스)메서드는 우선 인스턴스화가 되어야 된다.
		   따라서 객체생성(new)후 메서드를 호출할 수 있다.

		   Cat c = new Cat(); // heap 메모리에 인스턴스 변수와 인스턴스 메소드가 생성됨.

		   c.메서드([값,값...]); // 객체생성후 참조변수.메서드() 형식 사용.

      * 메서드 특징
         - 메서드명은 사용자 정의 식별자이기 때문에 임의로 지정 가능 ( 권장은 동사형, 소문자 )
	 - 반드시 호출해야 된다.
	 - 호출후 수행이 끝나면 호출한 곳으로 반드시 돌아온다.

   3) 메서드 형태 ( 파라미터가 있거나 없거나 또는 리턴값 있거나 없거나 )

    가.  파라미터가 없고 리터값도 없는 형식
      문법:
           public void 메서드명(){
               문장;
	   }
	예> 
	 public class Util{
	   public void method1(){
		System.outprintln("method1");
	   }
         }
      사용방법: 
	  Util u = new Util();
	  u.method1();

 
   나.  파라미터는 있고 리터값 없는 형식
      문법:
           public void 메서드명(변수,...){
               문장;
	   }

      예> 
	 public class Util{
	   public void method2(int n){
		System.outprintln("method2" + n);
	   }
	   public void method3(int n, int n2){
		System.outprintln("method2" + n + "\t" + n2);
	   }
         }

       사용방법: 
	  Util u = new Util();
	  u.method2(10);
	  u.method3(10,20);

#####################################################################
6일차 리뷰
1. 클래스
  - 자바의 최소한의 단위.
  - 구성요소
    변수(인스턴스변수, 멤버변수): 객체의 속성 저장용
    메서드(인스턴스메서드, 멤버메서드): 기능처리용. 일반적으로 변수의 핸들링 역할(수정, 조회)
    생성자: 변수 초기화용

  -문법:
        public 클래스명{ // 사용자정의 식별자, 첫글자 대문자, 의미있는 명사형 
	 
	    //인스턴스 변수
	    // 생성자
	    // 메서드

	}

  - 사용방법: 작성된 클래스는 반드시 객체 생성해야 된다.
      문법:
           클래스명  변수명 = new 클래스명([값, 값,...]);
     
      ==> 클래스의 멤버(인스턴스변수,메서드)가 heap 메모리에 생성된다.
          heap 메모리에 생성된 것은 '인스턴스(instance)'라고 부른다.


2. 생성자 ( constructor )
  
  역할: 인스턴스변수 초기화
  문법:
       public 클래스명([변수,..]){}

  특징: -반드시 호출해야 실행된다.
       ==> 호출방법 2가지
         가. 다른 클래스에서
	     new 클래스명([값,..]);
	 나. 자신 클래스에서
	     this([값,..]);

       -반드시 클래스명으로 지정해야 된다.
       -개발자가 명시적으로 생성자를 지정하지 않으면 자동으로 생성자를 제공한다. ( 기본 생성자, default 생성자 )
        ==> public 클래스명(){}
        단 개발자가 명시적으로 생성자를 지정하면 기본 생성자는 제공이 안된다.
       -오버로딩(overloading) 생성자가 가능하다.
        ==> 개념: 하나의 클래스안에 동일한 이름의 생성자가 여러개 지정이 가능함.
	==> 규칙: 반드시 인자 리스트(파라미터)가 다르면 가능하다.
	         인자리스트는 갯수,타입,순서 의미.
        ==> 장점: 재사용성 목적

3. 메서드 (method)
 
  1)용도: 기능처리. 
         일반적으로 인스턴스 변수와 관련된 기능처리이다. ( 변수값 수정, 변수값 조회, 유효성검사 기능등 )

  2)문법:
   
       public 리턴타입 메서드명([변수,...]){  // 파라미터는 없거나 여러개 지정 가능
	   문장1;
	   [return 값;]  // 리턴값,  리턴값은 없거나 반드시 한개만 지정 가능
       }

  3)특징:
       - 반드시 호출해야 실행된다.
         ==> 호출 방법은 ?
	    가. 다른 클래스에서
	        step1: 반드시 객체생성해야 된다.
		       클래스명  참조변수명 = new 클래스명([값,..]);
                step2: 참조변수명.메서드([값,...]);
 
	    나. 자신 클래스에서
	         step1: 반드시 객체생성해야 된다.
		       클래스명  참조변수명 = new 클래스명([값,..]);

		 step2: this.메서드([값,...]);
		        또는
                        메서드([값,...]);

  4) 메서드의 파라미터 및 리턴값의 따른 4가지 형식

    가. 파라미터 없고 리턴값 없는 경우
      문법:
         public class 클래스명{
           public void 메서드명(){
              문장;
	   }
	   public void 메서드명2(){
              문장;
	      this.메서드명(); //  메서드명();
	   }
	 }

      사용:
           클래스명  참조변수명 = new 클래스명();
           참조변수명.메서드명();

    나. 파라미터 있고 리턴값 없는 경우
      문법:
          public class 클래스명{
 
             public void 메서드명1(int n){
	     }
	     public void 메서드명1(String n){
	     }
	     public void 메서드명1(String n, int n2){
	     }
	  }
        사용:
           클래스명  참조변수명 = new 클래스명();
           참조변수명.메서드명1(10);
	   참조변수명.메서드명1("홍길동");
	   참조변수명.메서드명1("홍길동", 10);
 
     *오버로딩 메서드 ( overloading )
     - 개념: 하나의 클래스안에 동일한 이름의 메서드가 여러개 지정이 가능하다.
          단 식별하기 위해서 인자리스트( 갯수, 타입, 순서 )를 반드시 달라야 된다.
     - 장점: 재사용


    다. 파라미터 없고 리턴값 있는 경우
    라. 파라미터 있고 리턴값 있는 경우

 